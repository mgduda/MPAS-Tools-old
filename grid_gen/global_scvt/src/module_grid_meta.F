module grid_meta

   contains

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! SUBROUTINE WRITE_GRID
   !
   ! Create metadata for mesh and write out the complete grid information.
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine write_grid(rlat, rlon, n, vclat, vclon, nvc, alist, clist)
   
      use data_types
      use grid_constants
      use sphere_utilities
      use write_netcdf
      use scvt
   
      implicit none
   
      integer, intent(in) :: n, nvc
      real, dimension(n), intent(inout) :: rlat, rlon
      real, dimension(nvc), intent(inout) :: vclat, vclon
      type (adjacency_list) :: alist, clist
   
      integer, parameter :: maxEdges = 10

      type tree_pointer_list
         integer :: stage
         type (binary_tree), pointer :: p
      end type tree_pointer_list
   
      integer :: i, ii, j, js, k, prev_edge, next_edge, vtx, nObtuse, jj, iEdge, iFlag
      integer :: nCells, nEdges, nVertices, nVertLevels, nTracers
      integer, dimension(3) :: cellsOnTriangle
      integer, allocatable, dimension(:) :: permutation, indexToCellID, indexToEdgeID, indexToVertexID
      integer, allocatable, dimension(:) :: nEdgesOnCell, nEdgesOnEdge, nEdgesOnVertex, nCellsOnVertex
      integer, allocatable, dimension(:) :: tempEdgesOnEdge
      integer, allocatable, dimension(:,:) :: cellsOnEdge, edgesOnCell, verticesOnCell, cellsOnCell, &
                                              verticesOnEdge, edgesOnEdge, edgesOnVertex, cellsOnVertex
      integer, allocatable, dimension(:) :: isObtuse
      real, allocatable, dimension(:,:) :: weightsOnEdge, kiteAreasOnVertex
      integer :: temp
      logical :: tdrtest = .true.
      real :: sum_r, area, r, s, de, rtmp
      real, allocatable, dimension(:) :: latCell, lonCell, latEdge, lonEdge, angleEdge, latVertex, lonVertex, &
                                         lat1Edge, lon1Edge, lat2Edge, lon2Edge, dvEdge, dv1Edge, dv2Edge, dcEdge, &
                                         areaCell, areaTriangle, fEdge, fVertex, h_s, u_sbr
      real, allocatable, dimension(:,:,:) :: u, v, h, vh, circulation, vorticity, ke
      real, allocatable, dimension(:,:,:,:) :: tracers
      real, allocatable, dimension(:) :: xCell, yCell, zCell, xEdge, yEdge, zEdge, xVertex, yVertex, zVertex, meshDensity
      type (geo_point) :: vertex1GP, vertex2GP, cell1GP, cell2GP, cell3GP, edgeGP, edgeGP_prev, edgeGP_next, pCell
      type (geo_point) :: center
      type (geo_point), allocatable, dimension(:) :: points
      type (binary_tree), pointer :: treeRoot
      type (tree_pointer_list), allocatable, dimension(:) :: cursor
   

      !
      ! Compute number of cells
      !
      nCells = alist % nNodes
   
   
      !
      ! Compute number of edges
      !
      nEdges = alist % nNeighbors / 2

      
      !
      ! Compute number of vertices
      !
      nVertices = nEdges - nCells + 2      ! Euler's formula
   
   
      allocate(latCell(nCells)) 
      allocate(lonCell(nCells))
      allocate(meshDensity(nCells))
      allocate(xCell(nCells))
      allocate(yCell(nCells))
      allocate(zCell(nCells))
      allocate(latEdge(nEdges))
      allocate(lonEdge(nEdges))
      allocate(xEdge(nEdges))
      allocate(yEdge(nEdges))
      allocate(zEdge(nEdges))
      allocate(dvEdge(nEdges))
      allocate(dv1Edge(nEdges))
      allocate(dv2Edge(nEdges))
      allocate(dcEdge(nEdges))
      allocate(areaCell(nCells))
      allocate(areaTriangle(nVertices))
      allocate(angleEdge(nEdges))
      allocate(u_sbr(nEdges))
      allocate(latVertex(nVertices))
      allocate(lonVertex(nVertices))
      allocate(xVertex(nVertices))
      allocate(yVertex(nVertices))
      allocate(zVertex(nVertices))
      allocate(lat1Edge(nEdges))
      allocate(lon1Edge(nEdges))
      allocate(lat2Edge(nEdges))
      allocate(lon2Edge(nEdges))
      allocate(cellsOnEdge(2,nEdges))
      allocate(isObtuse(nVertices))
      allocate(edgesOnCell(maxEdges,nCells))
      allocate(verticesOnCell(maxEdges,nCells))
      allocate(verticesOnEdge(2,nEdges))
      allocate(edgesOnEdge(2*maxEdges,nEdges))
      allocate(edgesOnVertex(3,nVertices))
      allocate(cellsOnVertex(3,nVertices))
      allocate(tempEdgesOnEdge(2*maxEdges))
      allocate(weightsOnEdge(2*maxEdges,nEdges))
      allocate(kiteAreasOnVertex(3,nVertices))
      allocate(cellsOnCell(maxEdges,nCells))
      allocate(nEdgesOnCell(nCells))
      allocate(nEdgesOnEdge(nEdges))
      allocate(nEdgesOnVertex(nVertices))
      allocate(nCellsOnVertex(nVertices))
      allocate(cursor(nEdges))
   
   
      !
      ! Determine lat/lon for each cell
      !
      open(61,file='density.dat',status='unknown',form='formatted')
      do i=1,nCells
         latCell(i) = rlat(i)
         lonCell(i) = rlon(i)
         center % lat = latCell(i)
         center % lon = lonCell(i)
         write(61,'(f17.15)') density_for_point(center)
      end do
      close(61)


      !
      ! Determine lat/lon for each vertex
      !
      do i=1,nVertices
         latVertex(i) = vclat(i)
         lonVertex(i) = vclon(i)
      end do 

   
      !
      ! Construct a list of edges (actually, a BST)
      !
      nullify(treeRoot)
      do i=1,nCells
!write(6,'(a,i7,1x,f12.8,1x,f12.8)') 'Processing cell ', i, latCell(i), lonCell(i)
         areaCell(i) = 0.0
         nEdgesOnCell(i) = 0
         cell1GP % lat = latCell(i)
         cell1GP % lon = lonCell(i)
         do j = clist % start(i), clist % start(i) + clist % len(i) - 2 
!write(6,'(a,f12.8,1x,f12.8)') '   corner ', latVertex(clist % neighbor(j)), lonVertex(clist % neighbor(j))
            js = j+1
            cell2GP % lat = latVertex(clist % neighbor(j))
            cell2GP % lon = lonVertex(clist % neighbor(j))
            cell3GP % lat = latVertex(clist % neighbor(js))
            cell3GP % lon = lonVertex(clist % neighbor(js))
            areaCell(i) = areaCell(i) + triangle_area(cell1GP, cell2GP, cell3GP, 1.0)
            nEdgesOnCell(i) = nEdgesOnCell(i) + 1
            verticesOnCell(nEdgesOnCell(i),i) = clist % neighbor(j)

            call insert_edge_to_tree(i, &
                                     clist % neighbor(j), clist % neighbor(js), &
                                     vclat(clist % neighbor(j)), vclon(clist % neighbor(j)),   &
                                     vclat(clist % neighbor(js)), vclon(clist % neighbor(js)), &
                                     treeRoot)
         end do
   
         js = clist % start(i)
         cell2GP % lat = latVertex(clist % neighbor(j))
         cell2GP % lon = lonVertex(clist % neighbor(j))
         cell3GP % lat = latVertex(clist % neighbor(js))
         cell3GP % lon = lonVertex(clist % neighbor(js))
         areaCell(i) = areaCell(i) + triangle_area(cell1GP, cell2GP, cell3GP, 1.0)
         nEdgesOnCell(i) = nEdgesOnCell(i) + 1
         verticesOnCell(nEdgesOnCell(i),i) = clist % neighbor(j)

         call insert_edge_to_tree(i, &
                                  clist % neighbor(j), clist % neighbor(js), &
                                  vclat(clist % neighbor(j)), vclon(clist % neighbor(j)),   &
                                  vclat(clist % neighbor(js)), vclon(clist % neighbor(js)), &
                                  treeRoot)
!write(0,*) 'areaCell = ', areaCell(i)
      end do


      !
      ! Determine which cells are on each cell
      !
      do i=1,nCells
         k = 1
         do j = alist % start(i), alist % start(i) + alist % len(i) - 1 
            cellsOnCell(k,i) = alist % neighbor(j)
            k = k + 1
         end do
         do j=k,maxEdges
            cellsOnCell(j,i) = alist % neighbor(alist % start(i) + alist % len(i) - 1)
         end do
      end do

   
      !
      ! Determine which cells share each vertex
      !
      nCellsOnVertex(:) = 0
      CELL_LOOP: do i=1,nCells
         do j=1,nEdgesOnCell(i)
            nCellsOnVertex(verticesOnCell(j,i)) = nCellsOnVertex(verticesOnCell(j,i)) + 1
            if (nCellsOnVertex(verticesOnCell(j,i)) > 3) then
               write(0,*) 'We have too many cells sharing vertex ', verticesOnCell(j,i)
               cycle CELL_LOOP
            end if
            cellsOnVertex(nCellsOnVertex(verticesOnCell(j,i)),verticesOnCell(j,i)) = i
         end do
      end do CELL_LOOP


      !
      ! Compute area of each cell
      !
#if 0
      do i=1,nCells
         cell1GP % lat = latCell(i) 
         cell1GP % lon = lonCell(i) 
         areaCell(i) = 0.0
         do j=1,nEdgesOnCell(i)-1
            vertex1GP % lat = latVertex(verticesOnCell(j,i)) 
            vertex1GP % lon = lonVertex(verticesOnCell(j,i)) 
            vertex2GP % lat = latVertex(verticesOnCell(j+1,i)) 
            vertex2GP % lon = lonVertex(verticesOnCell(j+1,i)) 
            areaCell(i) = areaCell(i) + triangle_area(cell1GP, vertex1GP, vertex2GP, 1.0)
         end do
         vertex1GP % lat = latVertex(verticesOnCell(j,i)) 
         vertex1GP % lon = lonVertex(verticesOnCell(j,i)) 
         vertex2GP % lat = latVertex(verticesOnCell(1,i)) 
         vertex2GP % lon = lonVertex(verticesOnCell(1,i)) 
         areaCell(i) = areaCell(i) + triangle_area(cell1GP, vertex1GP, vertex2GP, 1.0)
      end do
#endif


      !
      ! Compute area of triangles associated with each vertex
      !
      do i=1,nVertices
         cell1GP % lat = latCell(cellsOnVertex(1,i))
         cell1GP % lon = lonCell(cellsOnVertex(1,i))
         cell2GP % lat = latCell(cellsOnVertex(2,i))
         cell2GP % lon = lonCell(cellsOnVertex(2,i))
         cell3GP % lat = latCell(cellsOnVertex(3,i))
         cell3GP % lon = lonCell(cellsOnVertex(3,i))
         areaTriangle(i) = triangle_area(cell1GP, cell2GP, cell3GP, 1.0)
      end do

      !
      ! Test to see if any of the triangles are obtuse
      !
      nObtuse = 0
      do i=1,nVertices
         cell1GP % lat = latCell(cellsOnVertex(1,i))
         cell1GP % lon = lonCell(cellsOnVertex(1,i))
         cell2GP % lat = latCell(cellsOnVertex(2,i))
         cell2GP % lon = lonCell(cellsOnVertex(2,i))
         cell3GP % lat = latCell(cellsOnVertex(3,i))
         cell3GP % lon = lonCell(cellsOnVertex(3,i))
         isObtuse(i) = obtuse(cell1GP, cell2GP, cell3GP)
         if(isObtuse(i).gt.0) nObtuse = nObtuse + 1
      end do
      write(6,*) ' number of obtuse triangles ', nObtuse


write(0,*) 'DID WE MAKE IT HERE?'


      write(0,*) 'There are ', nCells, ' cells and ', nEdges, ' edges' 
      write(0,*) ' '
      write(0,*) 'Total area of all cells is ',sum(areaCell(:))
      write(0,*) 'Total triangle area=',sum(areaTriangle(:))
      write(0,*) 'Total kite area=',sum(kiteAreasOnVertex(:,:))


      nVertLevels = 1
      nTracers = 1

      allocate(indexToCellID(nCells))
      allocate(indexToEdgeID(nEdges))
      allocate(indexToVertexID(nVertices))
      allocate(fEdge(nEdges))
      allocate(fVertex(nVertices))
      allocate(h_s(nCells))
      allocate(u(nVertLevels,nEdges,1))
      allocate(v(nVertLevels,nEdges,1))
      allocate(h(nVertLevels,nCells,1))
      allocate(vh(nVertLevels,nEdges,1))
      allocate(circulation(nVertLevels,nVertices,1))
      allocate(vorticity(nVertLevels,nVertices,1))
      allocate(ke(nVertLevels,nCells,1))
      allocate(tracers(nTracers,nVertLevels,nCells,1))

      u(1,:,1) = u_sbr(:)
      h(:,:,1) = 1000.0
      v(:,:,1) = 0.0
      vh(:,:,1) = 0.0
      circulation(:,:,1) = 0.0
      vorticity(:,:,1) = 0.0
      ke(:,:,1) = 0.0
      tracers(:,:,:,1) = 0.0

      call write_netcdf_init( &
                              nCells, &
                              nEdges, &
                              nVertices, &
                              maxEdges, &
                              nVertLevels, &
                              nTracers &
                              )

      call write_netcdf_fields( &
                                1, &
                                latCell, &
                                lonCell, &
                                meshDensity, &
                                xCell, &
                                yCell, &
                                zCell, &
                                indexToCellID, &
                                latEdge, &
                                lonEdge, &
                                xEdge, &
                                yEdge, &
                                zEdge, &
                                indexToEdgeID, &
                                latVertex, &
                                lonVertex, &
                                xVertex, &
                                yVertex, &
                                zVertex, &
                                indexToVertexID, &
                                cellsOnEdge, &
                                nEdgesOnCell, &
                                nEdgesOnEdge, &
                                edgesOnCell, &
                                edgesOnEdge, &
                                weightsOnEdge, &
                                dvEdge, &
                                dv1Edge, &
                                dv2Edge, &
                                dcEdge, &
                                angleEdge, &
                                areaCell, &
                                areaTriangle, &
                                cellsOnCell, &
                                verticesOnCell, &
                                verticesOnEdge, &
                                edgesOnVertex, &
                                cellsOnVertex, &
                                kiteAreasOnVertex, &
                                fEdge, &
                                fVertex, &
                                h_s, &
                                u, &
                                v, &
                                h, &
                                vh, &
                                circulation, &
                                vorticity, &
                                ke, &
                                tracers &
                               )

      call write_netcdf_finalize()


      !
      ! Write out a file compatible with metis for block decomposition
      !
      open(42,file='graph.info',form='formatted')
      write(42,*) nCells, nEdges
      do i=1,nCells
         do j=1,nEdgesOnCell(i)
            write(42,'(1x,i8)',advance='no') cellsOnCell(j,i)
         end do
         write(42,'(1x)')
      end do
      close(42)


      !
      ! The following information is written out to permit further refinement
      !    of a grid using the grid_gen code
      !
      open(22,file='locs.dat.out',form='formatted')
      write(22,*) nCells,nEdges
      do i=1,nCells
         write(22,'(10x,f22.10,f23.10,f23.10)') xCell(i), yCell(i), zCell(i)
      end do
      do i=1,nEdges
         write(22,'(10x,f22.10,f23.10,f23.10)') xEdge(i), yEdge(i), zEdge(i)
      end do
   !  do i=1,nCells
   !     write(22,'(f13.10,1x,f13.10)') latCell(i), lonCell(i)
   !  end do
   !  do i=1,nEdges
   !     write(22,'(f13.10,1x,f13.10)') latEdge(i), lonEdge(i)
   !  end do
      close(22)

      !
      ! Write out data for visualization in OpenDx
      !
      call write_OpenDX(       nCells, &
                               nVertices, &
                               xCell, &
                               yCell, &
                               zCell, &
                               xVertex, &
                               yVertex, &
                               zVertex, &
                               nEdgesOnCell, &
                               verticesOnCell, &
                               areaCell )


      deallocate(indexToCellID)
      deallocate(indexToEdgeID)
      deallocate(indexToVertexID)
      deallocate(fEdge)
      deallocate(fVertex)
      deallocate(h_s)
      deallocate(u)
      deallocate(v)
      deallocate(h)
      deallocate(vh)
      deallocate(circulation)
      deallocate(vorticity)
      deallocate(ke)
      deallocate(tracers)


      deallocate(cursor)
      deallocate(latCell)
      deallocate(lonCell)
      deallocate(xCell)
      deallocate(yCell)
      deallocate(zCell)
      deallocate(latEdge)
      deallocate(lonEdge)
      deallocate(xEdge)
      deallocate(yEdge)
      deallocate(zEdge)
      deallocate(dvEdge)
      deallocate(dv1Edge)
      deallocate(dv2Edge)
      deallocate(dcEdge)
      deallocate(areaCell)
      deallocate(areaTriangle)
      deallocate(angleEdge)
      deallocate(u_sbr)
      deallocate(latVertex)
      deallocate(lonVertex)
      deallocate(xVertex)
      deallocate(yVertex)
      deallocate(zVertex)
      deallocate(lat1Edge)
      deallocate(lon1Edge)
      deallocate(lat2Edge)
      deallocate(lon2Edge)
      deallocate(cellsOnEdge)
      deallocate(edgesOnCell)
      deallocate(verticesOnCell)
      deallocate(verticesOnEdge)
      deallocate(edgesOnEdge)
      deallocate(edgesOnVertex)
      deallocate(cellsOnVertex)
      deallocate(tempEdgesOnEdge)
      deallocate(weightsOnEdge)
      deallocate(kiteAreasOnVertex)
      deallocate(cellsOnCell)
      deallocate(nEdgesOnCell)
      deallocate(nEdgesOnEdge)
      deallocate(nEdgesOnVertex)
      deallocate(nCellsOnVertex)
   
   end subroutine write_grid
   
   
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! SUBROUTINE INSERT_EDGE_TO_TREE
   !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine insert_edge_to_tree(cellID, vertex1ID, vertex2ID, lat1, lon1, lat2, lon2, root)
   
      use data_types
   
      implicit none
   
      integer, intent(in) :: cellID
      integer, intent(in) :: vertex1ID, vertex2ID
      real, intent(in) :: lat1, lon1, lat2, lon2
      type (binary_tree), pointer :: root
   
      real :: tLat1, tLat2, tLon1, tLon2 
      integer :: tID1, tID2
      logical :: found
      type (binary_tree), pointer :: pre_cursor, cursor
   
      if (point_compare(lat1, lon1, lat2, lon2) > 0) then
         tLat1 = lat1
         tLon1 = lon1
         tLat2 = lat2
         tLon2 = lon2
         tID1 = vertex1ID
         tID2 = vertex2ID
      else
         tLat1 = lat2
         tLon1 = lon2
         tLat2 = lat1
         tLon2 = lon1
         tID1 = vertex2ID
         tID2 = vertex1ID
      end if
   
      if (.not. associated(root)) then
         allocate(root)
         root % lat1 = tLat1
         root % lon1 = tLon1
         root % lat2 = tLat2
         root % lon2 = tLon2
         root % vertex1 = tID1
         root % vertex2 = tID2
         root % node1 = cellID
         nullify(root % left)
         nullify(root % right)
         nullify(root % parent)
   
      else
   
         found = .false.
         cursor => root
         do while (associated(cursor) .and. .not. found)
            if (edge_compare(tLat1, tLon1, tLat2, tLon2, cursor % lat1, cursor % lon1, cursor % lat2, cursor % lon2) == 0) then
               found = .true.
            else if (edge_compare(tLat1, tLon1, tLat2, tLon2, cursor % lat1, cursor % lon1, cursor % lat2, cursor % lon2) > 0) then
               pre_cursor => cursor
               cursor => cursor % right
            else 
               pre_cursor => cursor
               cursor => cursor % left
            end if
         end do
   
         if (.not. found) then
            if (edge_compare(tLat1, tLon1, tLat2, tLon2, pre_cursor % lat1, pre_cursor % lon1, pre_cursor % lat2, pre_cursor % lon2) > 0) then
               allocate(pre_cursor % right)
               cursor => pre_cursor % right
            else
               allocate(pre_cursor % left)
               cursor => pre_cursor % left
            end if
            cursor % lat1 = tLat1
            cursor % lon1 = tLon1
            cursor % lat2 = tLat2
            cursor % lon2 = tLon2
            cursor % vertex1 = tID1
            cursor % vertex2 = tID2
            cursor % node1 = cellID
            cursor % parent => pre_cursor
            nullify(cursor % left)
            nullify(cursor % right)
         else
            cursor % node2 = cellID
         end if
   
      end if
   
   end subroutine insert_edge_to_tree
   
   
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! FUNCTION POINT_COMPARE
   !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   integer function point_compare(lat1, lon1, lat2, lon2)
   
      implicit none
   
      real, intent(in) :: lat1, lon1, lat2, lon2
   
      point_compare = -1
   
      if (lat1 > lat2) then
         point_compare = 1
      else if (lat1 == lat2) then
         if (lon1 > lon2) then
            point_compare = 1
         else if (lon1 == lon2) then
            point_compare = 0
         end if
      end if
   
   end function point_compare
   
   
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! FUNCTION EDGE_COMPARE
   !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   integer function edge_compare(aLat1, aLon1, aLat2, aLon2, bLat1, bLon1, bLat2, bLon2)
   
      implicit none
   
      real, intent(in) :: aLat1, aLon1, aLat2, aLon2, bLat1, bLon1, bLat2, bLon2 
   
      edge_compare = -1
   
      if (point_compare(aLat1,aLon1,bLat1,bLon1) > 0) then
         edge_compare = 1
      else if (point_compare(aLat1,aLon1,bLat1,bLon1) == 0) then
         if (point_compare(aLat2,aLon2,bLat2,bLon2) > 0) then
            edge_compare = 1
         else if (point_compare(aLat2,aLon2,bLat2,bLon2) == 0) then
            edge_compare = 0
         end if
      end if
   
   end function edge_compare
   
   
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! SUBROUTINE COMPUTE_EDGE_LATLON
   !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine compute_edge_latlon(cell1, cell2, vertex1, vertex2, edge)
   
      use data_types
      use sphere_utilities
   
      implicit none
   
      type (geo_point), intent(in) :: cell1, cell2, vertex1, vertex2
      type (geo_point), intent(out) :: edge
    
      call gc_intersect(cell1, cell2, vertex1, vertex2, edge) 

   end subroutine compute_edge_latlon

 
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! SUBROUTINE is_flipped_vertex_order
   !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   logical function is_flipped_vertex_order(latCell1, lonCell1, &
                                            latCell2, lonCell2, &
                                            latVertex1, lonVertex1, &
                                            latVertex2, lonVertex2)

      use data_types
      use sphere_utilities

      implicit none

      real, intent(in) :: latCell1, lonCell1, &
                          latCell2, lonCell2, &
                          latVertex1, lonVertex1, &
                          latVertex2, lonVertex2

      real :: xCell1, yCell1, zCell1
      real :: xCell2, yCell2, zCell2
      real :: xVertex1, yVertex1, zVertex1
      real :: xVertex2, yVertex2, zVertex2
      real :: xV1, yV1, zV1
      real :: xV2, yV2, zV2
      real :: ci, cj, ck
      type (geo_point) :: cell1, cell2, vertex1, vertex2

      cell1 % lat = latCell1
      cell1 % lon = lonCell1
      cell2 % lat = latCell2
      cell2 % lon = lonCell2
      vertex1 % lat = latVertex1
      vertex1 % lon = lonVertex1
      vertex2 % lat = latVertex2
      vertex2 % lon = lonVertex2
      
      call convert_lx(xCell1, yCell1, zCell1, 1.0, cell1) 
      call convert_lx(xCell2, yCell2, zCell2, 1.0, cell2) 
      call convert_lx(xVertex1, yVertex1, zVertex1, 1.0, vertex1) 
      call convert_lx(xVertex2, yVertex2, zVertex2, 1.0, vertex2) 

      xV1 = xCell2 - xCell1
      yV1 = yCell2 - yCell1
      zV1 = zCell2 - zCell1
      xV2 = xVertex2 - xVertex1
      yV2 = yVertex2 - yVertex1
      zV2 = zVertex2 - zVertex1

      ci = yV1*zV2 - zV1*yV2
      cj = zV1*xV2 - xV1*zV2
      ck = xV1*yV2 - yV1*xV2 

      if ((ci*xCell1 + cj*yCell1 + ck*zCell1) >= 0.0) then
         is_flipped_vertex_order = .false.
      else
         is_flipped_vertex_order = .true.
      end if

   end function is_flipped_vertex_order


   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! SUBROUTINE is_flipped_vertex_order2
   !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   logical function is_flipped_vertex_order2(edge, cell2, vertex2)

      use data_types
      use sphere_utilities
      use grid_constants

      implicit none

      type (geo_point), intent(in) :: edge, cell2, vertex2

      real :: xEdge, yEdge, zEdge
      real :: xCell2, yCell2, zCell2
      real :: xVertex2, yVertex2, zVertex2
      real :: angle

      call convert_lx(xEdge, yEdge, zEdge, 1.0, edge) 
      call convert_lx(xCell2, yCell2, zCell2, 1.0, cell2) 
      call convert_lx(xVertex2, yVertex2, zVertex2, 1.0, vertex2) 

      angle = plane_angle(xEdge, yEdge, zEdge, &
                          xCell2, yCell2, zCell2, &
                          xVertex2, yVertex2, zVertex2, &
                          xEdge, yEdge, zEdge)

      if (angle > 0.0 .and. angle < pii) then
         is_flipped_vertex_order2 = .false.
      else
         is_flipped_vertex_order2 = .true.
      end if

   end function is_flipped_vertex_order2


   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   ! SUBROUTINE ORDER_POINTS_CCW
   !
   ! Given a center around which the ordering should be done, the array of points
   !   is re-ordered in CCW order, taking the first point in the array to be the
   !   first point in the ordering, and the vector from the origin to center 
   !   as the normal vector of the suface containing the points at the center.
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine order_points_ccw(center, npts, points, permutation)

      use data_types
      use sphere_utilities
      use grid_constants

      implicit none
      
      type (geo_point), intent(in) :: center
      integer, intent(in) :: npts
      integer, dimension(npts), intent(inout) :: permutation
      type (geo_point), dimension(npts), intent(inout) :: points

      integer :: i, j
      integer :: itemp
      real :: rtemp
      real :: nx, ny, nz
      real :: px, py, pz
      real :: p0x, p0y, p0z
      real, dimension(npts) :: angle
      type (geo_point) :: ptemp

      call convert_lx(nx, ny, nz, 1.0, center)
      call convert_lx(p0x, p0y, p0z, 1.0, points(1))

      angle(1) = 0.0

      do i=2,npts 
         call convert_lx(px, py, pz, 1.0, points(i))
         angle(i) = plane_angle(nx, ny, nz, p0x, p0y, p0z, px, py, pz, nx, ny, nz)
         if (angle(i) < 0.0) angle(i) = angle(i) + 2.0*pii
         if (angle(i) > 2.0*pii) angle(i) = angle(i) - 2.0*pii
      end do

      do i=2,npts 
         do j=i+1,npts
            if (angle(j) < angle(i)) then
               rtemp = angle(i)
               angle(i) = angle(j)
               angle(j) = rtemp

               itemp = permutation(i)
               permutation(i) = permutation(j)
               permutation(j) = itemp
     
               ptemp = points(i)
               points(i) = points(j)
               points(j) = ptemp
            end if
         end do
      end do

   end subroutine order_points_ccw

   subroutine write_OpenDX(    nCells, &
                               nVertices, &
                               xCell, &
                               yCell, &
                               zCell, &
                               xVertex, &
                               yVertex, &
                               zVertex, &
                               nEdgesOnCell, &
                               verticesOnCell, &
                               areaCell )

      integer, intent(in) :: nCells
      integer, intent(in) :: nVertices
      real (kind=RKIND), dimension(:), intent(in) :: xCell
      real (kind=RKIND), dimension(:), intent(in) :: yCell
      real (kind=RKIND), dimension(:), intent(in) :: zCell
      real (kind=RKIND), dimension(:), intent(in) :: xVertex
      real (kind=RKIND), dimension(:), intent(in) :: yVertex
      real (kind=RKIND), dimension(:), intent(in) :: zVertex
      integer, dimension(:), intent(in) :: nEdgesOnCell
      integer, dimension(:,:), intent(in) :: verticesOnCell
      real (kind=RKIND), dimension(:), intent(in) :: areaCell

      character(len=80) :: a, b, c, d, e, f
      integer :: i, j, k, nVerticesTotal, iEdge, iLoop

      nVerticesTotal = 0
      do i=1,nCells
       nVerticesTotal = nVerticesTotal + nEdgesOnCell(i)
      enddo

      open(unit=1,file='dx/voronoi.dx',form='formatted',status='unknown')

      a = trim('object "positions list" class array type float rank 1 shape 3 items')
      b = trim('ascii data file vor.position.data')
      write(1,10) a, nVerticesTotal
      write(1,10) b
      write(1,*)
      10 format(a70,i10)
      
      a = trim('object "edge list" class array type int rank 0 items')
      b = trim('ascii data file vor.edge.data')
      c = trim('attribute "ref" string "positions"')
      write(1,10) a, nVerticesTotal
      write(1,10) b
      write(1,10) c
      write(1,*)
      
      a = trim('object "loops list" class array type int rank 0 items')
      b = trim('ascii data file vor.loop.data')
      c = trim('attribute "ref" string "edges"')
      write(1,10) a, nCells
      write(1,10) b
      write(1,10) c
      write(1,*)
      
      a = trim('object "face list" class array type int rank 0 items')
      b = trim('ascii data file vor.face.data')
      c = trim('attribute "ref" string "loops"')
      write(1,10) a, nCells
      write(1,10) b
      write(1,10) c
      write(1,*)
      
      a = trim('object 0  class array type float rank 0 items')
      b = trim('data file vor.area.data')
      c = trim('attribute "dep" string "faces"')
      write(1,10) a, nCells
      write(1,10) b
      write(1,10) c
      write(1,*)
      
      a = trim('object "area" class field')
      b = trim('component "positions"     "positions list"')
      c = trim('component "edges"         "edge list"')
      d = trim('component "loops"         "loops list"')
      e = trim('component "faces"         "face list"')
      f = trim('component "data"           0')
      write(1,10) a
      write(1,10) b
      write(1,10) c
      write(1,10) d
      write(1,10) e
      write(1,10) f

      close(1)

      open(unit=10,file='dx/vor.area.data',form='formatted',status='unknown')
      open(unit=11,file='dx/vor.face.data',form='formatted',status='unknown')
      open(unit=12,file='dx/vor.loop.data',form='formatted',status='unknown')
      open(unit=13,file='dx/vor.edge.data',form='formatted',status='unknown')
      open(unit=14,file='dx/vor.position.data',form='formatted',status='unknown')

      iLoop = 0
      iEdge = 0
      do i=1,nCells
       write(10,20) areaCell(i)
       write(11,21) i-1
       write(12,21) iLoop
       iLoop = iLoop + nEdgesOnCell(i)
       do j=1,nEdgesOnCell(i)
         write(13,21) iEdge
         iEdge = iEdge + 1
         k = verticesOnCell(j,i)
         write(14,22) xVertex(k), yVertex(k), zVertex(k)
       enddo
      enddo

 20   format(e20.10)
 21   format(i20)
 22   format(3e20.10)

      close(10)
      close(11)
      close(12)
      close(13)
      close(14)


   end subroutine write_OpenDX

   
end module grid_meta
